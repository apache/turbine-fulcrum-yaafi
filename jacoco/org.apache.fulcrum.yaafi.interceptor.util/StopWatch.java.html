<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StopWatch.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Fulcrum YAAFI</a> &gt; <a href="index.source.html" class="el_package">org.apache.fulcrum.yaafi.interceptor.util</a> &gt; <span class="el_source">StopWatch.java</span></div><h1>StopWatch.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
package org.apache.fulcrum.yaafi.interceptor.util;

/**
 * &lt;p&gt;
 * &lt;code&gt;StopWatch&lt;/code&gt; provides a convenient API for timings.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * To start the watch, call {@link #start()}. At this point you can:
 * &lt;/p&gt;
 * &lt;ul&gt;
 * &lt;li&gt;{@link #split()} the watch to get the time whilst the watch continues in
 * the background. {@link #unsplit()} will remove the effect of the split. At
 * this point, these three options are available again.&lt;/li&gt;
 * &lt;li&gt;{@link #suspend()} the watch to pause it. {@link #resume()} allows the
 * watch to continue. Any time between the suspend and resume will not be
 * counted in the total. At this point, these three options are available
 * again.&lt;/li&gt;
 * &lt;li&gt;{@link #stop()} the watch to complete the timing session.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;
 * It is intended that the output methods {@link #toString()} and
 * {@link #getTime()} should only be called after stop, split or suspend,
 * however a suitable result will be returned at other points.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * NOTE: As from v2.1, the methods protect against inappropriate calls. Thus you
 * cannot now call stop before start, resume before suspend or unsplit before
 * split.
 * &lt;/p&gt;
 *
 * &lt;p&gt;
 * 1. split(), suspend(), or stop() cannot be invoked twice &lt;br&gt;
 * 2. unsplit() may only be called if the watch has been split()&lt;br&gt;
 * 3. resume() may only be called if the watch has been suspend()&lt;br&gt;
 * 4. start() cannot be called twice without calling reset()
 * &lt;/p&gt;
 *
 * @author Henri Yandell
 * @author Stephen Colebourne
 * @since 2.0
 * @version $Id$
 */
public class StopWatch {

	// running states
	private static final int STATE_UNSTARTED = 0;
	private static final int STATE_RUNNING = 1;
	private static final int STATE_STOPPED = 2;
	private static final int STATE_SUSPENDED = 3;

	// split state
	private static final int STATE_UNSPLIT = 10;
	private static final int STATE_SPLIT = 11;

	/**
	 * The current running state of the StopWatch.
	 */
<span class="fc" id="L79">	private int runningState = STATE_UNSTARTED;</span>

	/**
	 * Whether the stopwatch has a split time recorded.
	 */
<span class="fc" id="L84">	private int splitState = STATE_UNSPLIT;</span>

	/**
	 * The start time.
	 */
<span class="fc" id="L89">	private long startTime = -1;</span>
	/**
	 * The stop time.
	 */
<span class="fc" id="L93">	private long stopTime = -1;</span>

	/**
	 * &lt;p&gt;
	 * Constructor.
	 * &lt;/p&gt;
	 */
<span class="fc" id="L100">	public StopWatch() {</span>
		// nothing to do
<span class="fc" id="L102">	}</span>

	/**
	 * &lt;p&gt;
	 * Start the stopwatch.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method starts a new timing session, clearing any previous values.
	 * &lt;/p&gt;
	 *
	 * @throws IllegalStateException if the StopWatch is already running.
	 */
	public void start() {
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">		if (this.runningState == STATE_STOPPED) {</span>
<span class="nc" id="L117">			throw new IllegalStateException(&quot;Stopwatch must be reset before being restarted. &quot;);</span>
		}
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">		if (this.runningState != STATE_UNSTARTED) {</span>
<span class="nc" id="L120">			throw new IllegalStateException(&quot;Stopwatch already started. &quot;);</span>
		}
<span class="fc" id="L122">		stopTime = -1;</span>
<span class="fc" id="L123">		startTime = System.currentTimeMillis();</span>
<span class="fc" id="L124">		this.runningState = STATE_RUNNING;</span>
<span class="fc" id="L125">	}</span>

	/**
	 * &lt;p&gt;
	 * Stop the stopwatch.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method ends a new timing session, allowing the time to be retrieved.
	 * &lt;/p&gt;
	 *
	 * @throws IllegalStateException if the StopWatch is not running.
	 */
	public void stop() {
<span class="pc bpc" id="L139" title="3 of 4 branches missed.">		if (this.runningState != STATE_RUNNING &amp;&amp; this.runningState != STATE_SUSPENDED) {</span>
<span class="nc" id="L140">			throw new IllegalStateException(&quot;Stopwatch is not running. &quot;);</span>
		}
<span class="fc" id="L142">		stopTime = System.currentTimeMillis();</span>
<span class="fc" id="L143">		this.runningState = STATE_STOPPED;</span>
<span class="fc" id="L144">	}</span>

	/**
	 * &lt;p&gt;
	 * Resets the stopwatch. Stops it if need be.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method clears the internal values to allow the object to be reused.
	 * &lt;/p&gt;
	 */
	public void reset() {
<span class="nc" id="L156">		this.runningState = STATE_UNSTARTED;</span>
<span class="nc" id="L157">		this.splitState = STATE_UNSPLIT;</span>
<span class="nc" id="L158">		startTime = -1;</span>
<span class="nc" id="L159">		stopTime = -1;</span>
<span class="nc" id="L160">	}</span>

	/**
	 * &lt;p&gt;
	 * Split the time.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method sets the stop time of the watch to allow a time to be extracted.
	 * The start time is unaffected, enabling {@link #unsplit()} to continue the
	 * timing from the original start point.
	 * &lt;/p&gt;
	 *
	 * @throws IllegalStateException if the StopWatch is not running.
	 */
	public void split() {
<span class="nc bnc" id="L176" title="All 2 branches missed.">		if (this.runningState != STATE_RUNNING) {</span>
<span class="nc" id="L177">			throw new IllegalStateException(&quot;Stopwatch is not running. &quot;);</span>
		}
<span class="nc" id="L179">		stopTime = System.currentTimeMillis();</span>
<span class="nc" id="L180">		this.splitState = STATE_SPLIT;</span>
<span class="nc" id="L181">	}</span>

	/**
	 * &lt;p&gt;
	 * Remove a split.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method clears the stop time. The start time is unaffected, enabling
	 * timing from the original start point to continue.
	 * &lt;/p&gt;
	 *
	 * @throws IllegalStateException if the StopWatch has not been split.
	 */
	public void unsplit() {
<span class="nc bnc" id="L196" title="All 2 branches missed.">		if (this.splitState != STATE_SPLIT) {</span>
<span class="nc" id="L197">			throw new IllegalStateException(&quot;Stopwatch has not been split. &quot;);</span>
		}
<span class="nc" id="L199">		stopTime = -1;</span>
<span class="nc" id="L200">		this.splitState = STATE_UNSPLIT;</span>
<span class="nc" id="L201">	}</span>

	/**
	 * &lt;p&gt;
	 * Suspend the stopwatch for later resumption.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method suspends the watch until it is resumed. The watch will not
	 * include time between the suspend and resume calls in the total time.
	 * &lt;/p&gt;
	 *
	 * @throws IllegalStateException if the StopWatch is not currently running.
	 */
	public void suspend() {
<span class="nc bnc" id="L216" title="All 2 branches missed.">		if (this.runningState != STATE_RUNNING) {</span>
<span class="nc" id="L217">			throw new IllegalStateException(&quot;Stopwatch must be running to suspend. &quot;);</span>
		}
<span class="nc" id="L219">		stopTime = System.currentTimeMillis();</span>
<span class="nc" id="L220">		this.runningState = STATE_SUSPENDED;</span>
<span class="nc" id="L221">	}</span>

	/**
	 * &lt;p&gt;
	 * Resume the stopwatch after a suspend.
	 * &lt;/p&gt;
	 *
	 * &lt;p&gt;
	 * This method resumes the watch after it was suspended. The watch will not
	 * include time between the suspend and resume calls in the total time.
	 * &lt;/p&gt;
	 *
	 * @throws IllegalStateException if the StopWatch has not been suspended.
	 */
	public void resume() {
<span class="nc bnc" id="L236" title="All 2 branches missed.">		if (this.runningState != STATE_SUSPENDED) {</span>
<span class="nc" id="L237">			throw new IllegalStateException(&quot;Stopwatch must be suspended to resume. &quot;);</span>
		}
<span class="nc" id="L239">		startTime += System.currentTimeMillis() - stopTime;</span>
<span class="nc" id="L240">		stopTime = -1;</span>
<span class="nc" id="L241">		this.runningState = STATE_RUNNING;</span>
<span class="nc" id="L242">	}</span>

	/**
	 * Get the time on the stopwatch.
	 *
	 * This is either the time between the start and the moment this method is
	 * called, or the amount of time between start and stop.
	 *
	 * @return the time in milliseconds
	 */
	public long getTime() {
<span class="pc bpc" id="L253" title="3 of 4 branches missed.">		if (this.runningState == STATE_STOPPED || this.runningState == STATE_SUSPENDED) {</span>
<span class="fc" id="L254">			return this.stopTime - this.startTime;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">		} else if (this.runningState == STATE_UNSTARTED) {</span>
<span class="nc" id="L256">			return 0;</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">		} else if (this.runningState == STATE_RUNNING) {</span>
<span class="nc" id="L258">			return System.currentTimeMillis() - this.startTime;</span>
		}
<span class="nc" id="L260">		throw new RuntimeException(&quot;Illegal running state has occured. &quot;);</span>
	}

	/**
	 * Get the split time on the stopwatch.
	 *
	 * This is the time between start and latest split.
	 *
	 * @return the split time in milliseconds
	 * @throws IllegalStateException if the StopWatch has not yet been split.
	 * @since 2.1
	 */
	public long getSplitTime() {
<span class="nc bnc" id="L273" title="All 2 branches missed.">		if (this.splitState != STATE_SPLIT) {</span>
<span class="nc" id="L274">			throw new IllegalStateException(&quot;Stopwatch must be split to get the split time. &quot;);</span>
		}
<span class="nc" id="L276">		return this.stopTime - this.startTime;</span>
	}

	/**
	 * Gets a summary of the time that the stopwatch recorded as a string.
	 *
	 * @return the time as a String
	 */
	public String toString() {
<span class="nc" id="L285">		return getTime() + &quot;ms&quot;;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>